"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.longPress = longPress;
exports.press = press;
var _eventBuilder = require("../event-builder");
var _utils = require("../utils");
var _act = _interopRequireDefault(require("../../act"));
var _componentTree = require("../../helpers/component-tree");
var _filterNodeByType = require("../../helpers/filterNodeByType");
var _pointerEvents = require("../../helpers/pointer-events");
var _hostComponentNames = require("../../helpers/host-component-names");
var _timers = require("../../helpers/timers");
var _constants = require("./constants");
var _warnAboutRealTimers = require("./utils/warnAboutRealTimers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function press(element) {
  await basePress(this.config, element);
}
async function longPress(element, options = {
  duration: 500
}) {
  await basePress(this.config, element, options);
}
const basePress = async (config, element, options = {
  duration: 0
}) => {
  // Text and TextInput components are mocked in React Native preset so the mock
  // doesn't implement the pressability class
  // Thus we need to call the props directly on the host component
  if (isEnabledHostText(element) || isEnabledTextInput(element)) {
    await triggerMockPressEvent(config, element, options);
    return;
  }
  if (isEnabledTouchResponder(element)) {
    await triggerPressEvent(config, element, options);
    return;
  }
  const hostParentElement = (0, _componentTree.getHostParent)(element);
  if (!hostParentElement) {
    return;
  }
  await basePress(config, hostParentElement, options);
};
const triggerPressEvent = async (config, element, options = {
  duration: 0
}) => {
  const areFakeTimersEnabled = (0, _timers.jestFakeTimersAreEnabled)();
  if (!areFakeTimersEnabled) {
    (0, _warnAboutRealTimers.warnAboutRealTimers)();
  }
  await (0, _utils.wait)(config);
  await (0, _act.default)(async () => {
    element.props.onResponderGrant({
      ..._eventBuilder.EventBuilder.Common.touch(),
      dispatchConfig: {
        registrationName: 'onResponderGrant'
      }
    });
    await (0, _utils.wait)(config, options.duration);
    element.props.onResponderRelease({
      ..._eventBuilder.EventBuilder.Common.touch(),
      dispatchConfig: {
        registrationName: 'onResponderRelease'
      }
    });
    if (_constants.DEFAULT_MIN_PRESS_DURATION - options.duration > 0) {
      await (0, _utils.wait)(config, _constants.DEFAULT_MIN_PRESS_DURATION - options.duration);
    }
  });
};
const isEnabledTouchResponder = element => {
  return (0, _pointerEvents.isPointerEventEnabled)(element) && element.props.onStartShouldSetResponder?.();
};
const isEnabledHostText = element => {
  return (0, _filterNodeByType.filterNodeByType)(element, (0, _hostComponentNames.getHostComponentNames)().text) && (0, _pointerEvents.isPointerEventEnabled)(element) && !element.props.disabled && element.props.onPress;
};
const isEnabledTextInput = element => {
  return (0, _filterNodeByType.filterNodeByType)(element, (0, _hostComponentNames.getHostComponentNames)().textInput) && (0, _pointerEvents.isPointerEventEnabled)(element) && element.props.editable !== false;
};
const triggerMockPressEvent = async (config, element, options = {
  duration: 0
}) => {
  const {
    onPressIn,
    onPress,
    onPressOut
  } = element.props;
  await (0, _utils.wait)(config);
  if (onPressIn) {
    onPressIn(_eventBuilder.EventBuilder.Common.touch());
  }
  if (onPress) {
    onPress(_eventBuilder.EventBuilder.Common.touch());
  }
  await (0, _utils.wait)(config, options.duration);
  if (onPressOut) {
    if (_constants.DEFAULT_MIN_PRESS_DURATION - options.duration > 0) {
      await (0, _utils.wait)(config, _constants.DEFAULT_MIN_PRESS_DURATION - options.duration);
    }
    onPressOut(_eventBuilder.EventBuilder.Common.touch());
  }
};
//# sourceMappingURL=press.js.map