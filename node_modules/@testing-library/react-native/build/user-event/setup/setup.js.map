{"version":3,"file":"setup.js","names":["_timers","require","_press","_type","universalJestAdvanceTimersBy","ms","jestFakeTimersAreEnabled","jest","advanceTimersByTime","Promise","resolve","defaultOptions","delay","advanceTimers","setup","options","config","createConfig","instance","createInstance","api","press","bind","longPress","type","Object","assign"],"sources":["../../../src/user-event/setup/setup.ts"],"sourcesContent":["import { ReactTestInstance } from 'react-test-renderer';\nimport { jestFakeTimersAreEnabled } from '../../helpers/timers';\nimport { press, longPress } from '../press';\nimport { type } from '../type';\nimport { PressOptions } from '../press/press';\n\nexport interface UserEventSetupOptions {\n  /**\n   * Between some subsequent inputs like typing a series of characters\n   * the code execution is delayed per `setTimeout` for (at least) `delay` seconds.\n   * This moves the next changes at least to next macro task\n   * and allows other (asynchronous) code to run between events.\n   *\n   * `null` prevents `setTimeout` from being called.\n   *\n   * @default 0\n   */\n  delay?: number;\n\n  /**\n   * Function to be called to advance fake timers. Setting it is necessary for\n   * fake timers to work.\n   *\n   * @example jest.advanceTimersByTime\n   */\n  advanceTimers?: (delay: number) => Promise<void> | void;\n}\n\n/**\n * This functions allow wait to work correctly under both real and fake Jest timers.\n */\nfunction universalJestAdvanceTimersBy(ms: number) {\n  if (jestFakeTimersAreEnabled()) {\n    return jest.advanceTimersByTime(ms);\n  } else {\n    return Promise.resolve();\n  }\n}\n\nconst defaultOptions: Required<UserEventSetupOptions> = {\n  delay: 0,\n  advanceTimers: universalJestAdvanceTimersBy,\n};\n\n/**\n * Creates a new instance of user event instance with the given options.\n *\n * @param options\n * @returns\n */\nexport function setup(options?: UserEventSetupOptions) {\n  const config = createConfig(options);\n  const instance = createInstance(config);\n  return instance;\n}\n\nexport interface UserEventConfig {\n  delay: number;\n  advanceTimers: (delay: number) => Promise<void> | void;\n}\n\nfunction createConfig(options?: UserEventSetupOptions): UserEventConfig {\n  return {\n    ...defaultOptions,\n    ...options,\n  };\n}\n\nexport interface UserEventInstance {\n  config: UserEventConfig;\n  press: (element: ReactTestInstance) => Promise<void>;\n  longPress: (\n    element: ReactTestInstance,\n    options?: PressOptions\n  ) => Promise<void>;\n  type: (element: ReactTestInstance, text: string) => Promise<void>;\n}\n\nfunction createInstance(config: UserEventConfig): UserEventInstance {\n  const instance = {\n    config,\n  } as UserEventInstance;\n\n  // We need to bind these functions, as they access the config through 'this.config'.\n  const api = {\n    press: press.bind(instance),\n    longPress: longPress.bind(instance),\n    type: type.bind(instance),\n  };\n\n  Object.assign(instance, api);\n  return instance;\n}\n"],"mappings":";;;;;;AACA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAyBA;AACA;AACA;AACA,SAASG,4BAA4BA,CAACC,EAAU,EAAE;EAChD,IAAI,IAAAC,gCAAwB,EAAC,CAAC,EAAE;IAC9B,OAAOC,IAAI,CAACC,mBAAmB,CAACH,EAAE,CAAC;EACrC,CAAC,MAAM;IACL,OAAOI,OAAO,CAACC,OAAO,CAAC,CAAC;EAC1B;AACF;AAEA,MAAMC,cAA+C,GAAG;EACtDC,KAAK,EAAE,CAAC;EACRC,aAAa,EAAET;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACO,SAASU,KAAKA,CAACC,OAA+B,EAAE;EACrD,MAAMC,MAAM,GAAGC,YAAY,CAACF,OAAO,CAAC;EACpC,MAAMG,QAAQ,GAAGC,cAAc,CAACH,MAAM,CAAC;EACvC,OAAOE,QAAQ;AACjB;AAOA,SAASD,YAAYA,CAACF,OAA+B,EAAmB;EACtE,OAAO;IACL,GAAGJ,cAAc;IACjB,GAAGI;EACL,CAAC;AACH;AAYA,SAASI,cAAcA,CAACH,MAAuB,EAAqB;EAClE,MAAME,QAAQ,GAAG;IACfF;EACF,CAAsB;;EAEtB;EACA,MAAMI,GAAG,GAAG;IACVC,KAAK,EAAEA,YAAK,CAACC,IAAI,CAACJ,QAAQ,CAAC;IAC3BK,SAAS,EAAEA,gBAAS,CAACD,IAAI,CAACJ,QAAQ,CAAC;IACnCM,IAAI,EAAEA,UAAI,CAACF,IAAI,CAACJ,QAAQ;EAC1B,CAAC;EAEDO,MAAM,CAACC,MAAM,CAACR,QAAQ,EAAEE,GAAG,CAAC;EAC5B,OAAOF,QAAQ;AACjB"}